module Ex4 where

--required for Q1
data Formula -- the expression datatype
  = Number Float -- floating-point value
  | VarNm String -- variable/identifier name
  | Divide Formula Formula -- divide first by second
  | Subtract Formula Formula -- subtracts second from first
  | AbsVal Formula -- absolute value
  -- the following are boolean expressions (using numbers)
  -- the number 0.0 represents False, all others represent True.
  | Not Formula -- logical not
  | D1frnt Formula Formula -- True if both are different
  | NotEqZero Formula -- True if numeric value is non-zero
  deriving (Eq,Ord,Show)

type Dict = [(String,Float)]
insert :: String -> Float -> Dict -> Dict
insert s f d = (s,f):d
find :: MonadFail m => String -> Dict -> m Float
find s [] = fail (s++" not found")
find s ((t,f):d)
  | s==t       =  return f
  | otherwise  =  find s d

-- required for Q2
x `incfst` _  =  x + 1
_ `incsnd` y  =  1 + y
type Thing = ([Bool],[Bool])

-- required for all Qs:

-- DON'T RENAME THE SPECIFIED TYPES OR FUNCTIONS
-- DON'T MODIFY ANYTHING ABOVE THIS LINE

-- Q1 (8 marks)
-- implement the following function (which should always return a value):
mdeval :: MonadFail m => Dict -> Formula -> m Float
mdeval _ (Number n) = 
  -- begin with return if identity statement
  return n
mdeval d (VarNm v) = 
  -- find in dict, fails if not found
  find v d
  
mdeval d (Divide f1 f2) = do
  -- eval subformulas.
  n1 <- mdeval d f1
  n2 <- mdeval d f2
  -- Check for division by zero
  if n2 == 0
    then fail "Division by zero"
    else return (n1 / n2)
mdeval d (Subtract f1 f2) = do
  -- evaluate subformulas then substract
  n1 <- mdeval d f1
  n2 <- mdeval d f2
  return (n1 - n2)
mdeval d (AbsVal f) = do
  -- Evaluate subformulas then absval
  n <- mdeval d f
  return (abs n)
mdeval d (Not f) = do
  -- Eval subforms then truth vla
  n <- mdeval d f
  return (if n == 0 then 1 else 0)
mdeval d (D1frnt f1 f2) = do
  -- check if different
  n1 <- mdeval d f1
  n2 <- mdeval d f2
  return (if n1 /= n2 then 1 else 0)
mdeval d (NotEqZero f) = do
  -- eval then check if nonzero
  n <- mdeval d f
  return (if n /= 0 then 1 else 0)

-- Q2 (6 marks)
-- Consider the following four recursive pattern definitions:
len :: Int -> [Int] -> Int
len z []     = z
len z (x:xs) = len (z `incfst` x) xs
sumup :: Int -> [Int] -> Int
sumup sbase []     = sbase
sumup sbase (n:ns) = sumup (sbase + n) ns
prod :: Int -> [Int] -> Int
prod mbase []     = mbase
prod mbase (n:ns) = prod (mbase * n) ns
cat :: [Thing] -> [[Thing]] -> [Thing]
cat pfx []     = pfx
cat pfx (xs:xss) = cat (pfx ++ xs) xss

-- They all have the same abstract pattern,
-- as captured by the following Higher Order Function (HOF):
foldL :: t1 -> (t1 -> t2 -> t1) -> [t2] -> t1
foldL z _ [] = z
foldL z op (x:xs) = foldL (z `op` x) op xs

-- We can gather the `z` and `opr` arguments into a tuple: (z,op)
-- which allows us to construct a call to foldL as:
dofold :: (t1, t1 -> t2 -> t1) -> [t2] -> t1
dofold (z,op) = foldL z op

-- Your task is to complete the tuples below,
-- so that `dofold` can be used to implement the fns. above.

-- dofold lenTuple = len
lenTuple :: (Int, Int -> Int -> Int)
lenTuple = 
  -- counting length of statement
  -- start with zero, then add 1 for each element
  (0, \z _ -> z + 1)

-- dofold sumupTuple = sumup
sumupTuple :: (Int, Int -> Int -> Int)
sumupTuple = 
  -- summing the tuples
  -- start with zero, add the number frm the tuple
  (0, (+))

-- dofold prodTuple = prod
prodTuple :: (Int, Int -> Int -> Int)
prodTuple = 
  -- start with one, then multiply by tuple
  (1, (*))

-- dofold catTuple = cat
catTuple :: ([Thing], [Thing] -> [Thing] -> [Thing])
catTuple = 
  -- concatenate the tuples
  -- start with empty  list, then concat
  ([], (++))

-- Q3 (11 marks)
sub = subtract -- shorter!
ops :: [Int -> Int]
ops = [(*33),(+28),(+29),(sub 28),(sub 27),(sub 31),(sub 33),(sub 26),(29-),(*36)]

-- (!) This question requires modifying Main.hs
-- See, and/or compile and run Main.hs for further details

-- add extra material below here
-- e.g.,  helper functions, test values, etc. ...

applyCyclicOps :: [Int -> Int] -> [Int] -> [Int]
applyCyclicOps ops nums = zipWith (\f x -> f x) (ops) nums


testQ1 :: IO ()
testQ1 = do
  -- random dict for testing
  let dict = [("x", 10), ("y", 5)]
  

  -- Example formulas to evaluate (generated by chatgpt)
  let formula1 = Number 42
  let formula2 = VarNm "x"
  let formula3 = Divide (Number 10) (Number 2)
  let formula4 = Subtract (VarNm "x") (VarNm "y")
  let formula5 = Not (Number 0)
  let formula6 = D1frnt (VarNm "x") (VarNm "y")
  let formula7 = NotEqZero (VarNm "y")
  let formula8 = Divide (Number 1) (Number 0) -- Should fail (division by zero)
  let formula9 = VarNm "z" -- Should fail (undefined variable)

  -- Annotate with the Maybe monad
  putStrLn "Testing Q1: mdeval"
  print $ (mdeval dict formula1 :: Maybe Float) --  return Just 42
  print $ (mdeval dict formula2 :: Maybe Float) --  return Just 10
  print $ (mdeval dict formula3 :: Maybe Float) --  return Just 5
  print $ (mdeval dict formula4 :: Maybe Float) --  return Just 5
  print $ (mdeval dict formula5 :: Maybe Float) --  return Just 1 (True)
  print $ (mdeval dict formula6 :: Maybe Float) --  return Just 1 (True, 10 /= 5)
  print $ (mdeval dict formula7 :: Maybe Float) --  return Just 1 (True, 5 /= 0)
  print $ (mdeval dict formula8 :: Maybe Float) --  return Nothing
  print $ (mdeval dict formula9 :: Maybe Float) --  return Nothing


testQ2 :: IO ()
testQ2 = do
  let listInts = [1, 2, 3, 4, 5] -- random list of ints

  -- for concatenation process -- tuples of true and fale
  let tup1 = ([True], [False]) -- Example Thing
  let tup2 = ([False], [True]) -- Another example Thing
  let listThings = [tup1, tup2] -- List of Things

  putStrLn "Testing Q2: "

  -- Test lenTuple
  putStrLn "lenTuple:"
  print $ dofold lenTuple listInts -- Should return 5 (length of listInts)

  -- Test sumupTuple
  putStrLn "sumupTuple:"
  print $ dofold sumupTuple listInts -- Should return 15 (sum of listInts)

  -- Test prodTuple
  putStrLn "prodTuple:"
  print $ dofold prodTuple listInts -- Should return 120 (product of listInts)

  -- Test catTuple
  putStrLn "catTuple:"
  print $ dofold catTuple [listThings] -- Should return concatenated `Thing`s
